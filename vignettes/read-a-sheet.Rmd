---
title: "Read an Excel Sheet"
author: "Jennifer Bryan"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
library(rprojroot)
devtools::load_all(find_package_root_file())
```

*Using a function I wrote while exploring all the files that make up an xlsx.*

Apply it to mini gapminder.

```{r}
mini_gap_path <- system.file("sheets", "mini-gap.xlsx", package = "rexcel")
mini_gap_workbook <- rexcel_workbook(mini_gap_path)
str(mini_gap_workbook, max.level = 1)
```

What's here?

  * `xlsx_path`: path to the xlsx
  * `reg_time`: time xlsx was processed
  * `manifest`: file list for the xlsx zip archive
  * `content_types`: tbl representing `[Content_Types].xml`
  * `sheets`: tbl representing `xl/workbook.xml`
  * `sheets_df`:
    - This is really the only thing I created.
    - A tbl with one row per worksheet, from joining `sheets` and `workbook_rels`
  * `shared_strings`: character vector representing `xl/sharedStrings.xml`
  * `styles`: list of tbls from `xl/styles.xml` (ok, I admit, I stopped after parsing fonts)
  * `workbook_rels`:
    - tbl that links target files to `Id`s, also gives file type
    - example: tells you that `Id = rId4` refers to `Target` file `xl/worksheets/sheetX.xml`
    - comes from `xl/_rels/workbook.xml.rels`
  * `worksheet_rels`:
    - *I'm still figuring this one out but it's about files or external resources (potentially) referred to from worksheets*
    - comes from files like` xl/worksheets/_rels/(sheet[0-9]+).xml.rels`
  
  

Apply it to formula and formatting sheet.

```{r}
ff_path <- system.file("sheets", "gs-test-formula-formatting.xlsx",
                       package = "rexcel")
rexcel_workbook(ff_path)
```

*Here I'm exploring the existing sheet reading functionality, using the vignette format. This is not an actual vignette!*

Peeling the many-layered onion that is `rexcel_read()` until I get at the XML for a worksheet. Wish me luck.

We'll work with an example sheet created for `googlesheets` that has alot of formulas and formatting going.

Objective 1: create a `linen::workbook` object. Dropping into code inside `rexcel_read_workbook()`.

```{r}
(ff_path <- system.file("sheets", "gs-test-formula-formatting.xlsx",
                        package = "rexcel"))

## enter rexcel_read_workbook()
path <- ff_path
sheets <- 1L

## this gets info about the files inside the zip archive
dat <- xlsx_read_workbook(path)
dat$rels   ## ?files in the zip archive?
dat$sheets ## ?files corresponding to worksheets?
(sheets <- xlsx_sheet_names(dat)[sheets])

(strings <- xlsx_read_shared_strings(path))
(date_offset <- xlsx_date_offset(path))

style_xlsx <- xlsx_read_style(path)
str(style_xlsx, max.level = 1)
(lookup <- tibble::data_frame(
  font    = style_xlsx$cell_xfs$font_id,
  fill    = style_xlsx$cell_xfs$fill_id,
  border  = style_xlsx$cell_xfs$border_id,
  num_fmt = style_xlsx$cell_xfs$num_fmt_id))

## numeric formatting
n <- max(style_xlsx$num_fmts$num_format_id)
fmt <- rep(NA_character_, n)
fmt[seq_along(xlsx_format_codes())] <- xlsx_format_codes()
fmt[style_xlsx$num_fmts$num_format_id] <- style_xlsx$num_fmts$format_code
num_fmt <- tibble::data_frame(num_fmt = fmt)
style <- linen::linen_style(lookup, font = style_xlsx$fonts,
                            fill = style_xlsx$fills,
                            border = style_xlsx$borders,
                            num_fmt = num_fmt)

(workbook <- linen::workbook(sheets, style, dat$defined_names))
```

Objective 2: Visit and extract information for all requested worksheets.

In this case, I'm just reading the first and only sheet. This loop appears in `rexcel_read_workbook()` and calls `rexcel_read_worksheet()` for each requested worksheet. This is the loop and function we eventually exit from and this `workbook` object is what's returned.

```{r}
## enter rexcel_read_worksheet()
## rexcel_read_worksheet(path, s, workbook, dat, strings, style, date_offset)
(sheet <- sheets[1])
(sheet_idx <- match(sheet, workbook$names))
(sheet_name <- sheet)

(target <- xlsx_internal_sheet_name(sheet, dat))
(rels <- xlsx_read_rels(path, target))
```

Now we drop down into a lower-level non-exported function, `xlsx_read_sheet()`.

```{r}
## enter xlsx_read_sheet()
(file <- xlsx_internal_sheet_name(sheet_idx, dat))
xml <- xlsx_read_file(path, file) ## at last! the xml! w00t!
(ns <- xml2::xml_ns(xml)) ## much less w00t now :(

(merged <- xlsx_read_merged(xml, ns))
(view <- xlsx_ct_worksheet_views(xml, ns))
(cols <- xlsx_ct_cols(xml, ns)) # NOTE: not used yet

## this is where it's at!
(cell_dat <- xlsx_parse_cells(xml, ns, strings, style, date_offset))

## not even sure what this is
(rows <- cell_dat$rows)

## this is where cells come from  
(cells <- linen::cells(cell_dat$cells$ref, cell_dat$cells$style,
                       cell_dat$cells$type, cell_dat$cells$value,
                       cell_dat$cells$formula))

## in real life and in other sheets, it's possible comments will be populated
## but not in this sheet
comments <- NULL
```

Now we gather everything we've learned about this worksheet into a `linen::worksheet` object.

```{r}
(ws <- linen::worksheet(sheet_name, cols, rows, cells, merged, view, comments,
                        workbook))
```

If we had other sheets to read, that would be done now. Ultimately this `workbook` is returned.
