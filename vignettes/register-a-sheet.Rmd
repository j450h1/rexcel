---
title: "Register an Excel Sheet"
author: "Jennifer Bryan"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Register an Excel Sheet}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, cache = FALSE}  
knitr::opts_chunk$set(error = TRUE)  
```

```{r}
library(rprojroot)
devtools::load_all(find_package_root_file())
```

A walk through the code in `rexcel_register()`. I wrote this function to make myself better acquainted with the files that make up an xlsx and with `rexcel`. It could evolve into something useful and/or some of this could be incorporated into `rexcel_read_workbook()` or `rexcel_read_worksheet()`.

Philosophy, at least in theory:

  * Don't error unless it's an invalid xlsx file. Try to do something useful.
  * Read one file at a time.
  * If a file exists, read it.
  * Process only enough to create the minimal R object.
  * Inner functions always take `path` to xlsx as primary or only argument.
  * Inner functions always return a single object.
  * Why? So it's easy to "drop in" on a problematic xlsx or to work on `rexcel`. I find it hard to do this when low-level functions work with lists that combine different objects and objects that come from different files. If you haven't run a bunch of other internal code first (or if some of that failed), it's hard to get into the state you need to be in to troubleshoot.

### Example sheets

We illustrate different xlsx features using different example sheets. Pre-store their paths to make this easier.

```{r}
mini_gap_path <- system.file("sheets", "mini-gap.xlsx", package = "rexcel")
ff_path <- system.file("sheets", "gs-test-formula-formatting.xlsx",
                       package = "rexcel")
ek_path <- system.file("sheets", "Ekaterinburg_IP_9.xlsx", package = "rexcel")
ek2_path <- system.file("sheets", "Ekaterinburg_IP_9-RESAVED.xlsx",
                        package = "rexcel")
dn_path <- system.file("sheets", "defined-names.xlsx", package = "rexcel")
gabe_path <- system.file("sheets", "gabe.xlsx", package = "rexcel")
```

### Walk through `rexcel_register()`

`path` is path to the xlsx and is the only argument. We'll use different example sheets as we go. Let's start with mini Gapminder.

`is_xlsx()` runs sanity checks to make sure this looks like valid xlsx.

```{r}
is_xlsx(mini_gap_path)
```

### `manifest` = file list

`manifest` holds a list of files in the zip archive.

```{r}
manifest <- xlsx_list_files(mini_gap_path)
print(manifest, n = Inf)
```

Overview of manifests I've seen. *TO DO: cross-check/enhance this with some actual research in the spec or other resources we like.*

  * Workbook infrastructure
    - [Content_Types].xml
    - _rels/.rels *boring? I don't currently process*
    - xl/workbook.xml
    - xl/_rels/workbook.xml.rels
    - xl/sharedStrings.xml *doesn't necessarily exist*
    - xl/styles.xml
    - docProps/core.xml *(seen but not inspected in defined_names.xlsx)*
    - docProps/app.xml *(ditto)*
  * Worksheet: one main file per sheet
    - xl/worksheets/sheet1.xml, xl/worksheets/sheet2.xml, and so on, is typical
    - but xl/worksheets/sheet.xml is also possible!
  * Worksheet: a `rels` file for each sheet
    - xl/worksheets/_rels/sheet1.xml.rels and so on
  * Worksheet: a file of drawings?
    - xl/drawings/worksheetdrawing1.xml and so on

The Ekaterinburg sheet from [readxl/#80](https://github.com/hadley/readxl/issues/80) has unusual structure. It was created by an undisclosed BI system but I include it here because the R packages that [wrap the Apache POI](https://poi.apache.org/spreadsheet/index.html) can read it just fine. So we should be able to return something informative for it.

Note the single sheet is referred to as `sheet`, not `sheet1`, and there is no associated `drawings` file.

```{r}
print(xlsx_list_files(ek_path), n = Inf)
```

If you open that workbook in Excel and resave it, things look different.

```{r}
print(xlsx_list_files(ek2_path), n = Inf)
```

We gain `docProps/app.xml`, `docProps/core.xml`, and `xl/theme/theme1.xml` and the single sheet is now referred to as `sheet1`, not just `sheet`. Still no drawings, though.

Conclusion: there is a lot of variety in the manifest.

### [Content_Types].xml

The `ct` object created from `[Content_Types].xml` is a tibble associating content types with extensions or specific files:

  * two "general" rows for the extensions `.xml` and `.rels`
  * other rows for specific files seen in the manifest *I gather these override the general types associated with extensions?*

```{r}
(ct <- xlsx_read_Content_Types(mini_gap_path))
#setdiff(manifest$name, gsub("^\\/", "", ct$part_name))
#intersect(gsub("^\\/", "", ct$part_name), manifest$name)
```

### `sheets` info from xl/workbook.xml

Among many other things in `xl/workbook.xml`, there is one xml node per worksheet, which we use to make `sheets`. It's a tibble with one row per worksheet and these variables:

  * `name`: e.g., "Africa" *I assume this is name of the tab*
  * `state`: "visible" *(or what else ... "invisible"?), might be `NA`*
  * `sheet_id`: integer *I assume this is order perceived by user*
  * `id`: character, e.g., `"rId5"` *a key that comes up elsewhere*

```{r}
(sheets <- xlsx_read_workbook_sheets(mini_gap_path))
```

Quick tour of similar info for other example sheets:

```{r}
xlsx_read_workbook_sheets(ff_path)
xlsx_read_workbook_sheets(ek_path)
xlsx_read_workbook_sheets(ek2_path)
xlsx_read_workbook_sheets(dn_path)
xlsx_read_workbook_sheets(gabe_path)
```

### Named ranges from xl/workbook.xml

Cell ranges can be named in Excel and subsequently used in formulas. These are described in `xl/workbook.xml` in the `definedName` nodes. Jenny has seen one node structure in the example she created, which differs from what Rich anticipated (presumably based on the spec?). Furthermore, Ekaterinburg has novel namespacing as well. See the comments in source for `xlsx_read_workbook_defined_names()` for details. Expect future pain here.

If a workbook has no named ranges, this will be `NULL`, e.g., as for mini Gapminder. Currently we have two example sheets with named ranges, `defined-names.xlsx` and `gabe.xlsx`. `defined-names.xlsx` was a planned example sheet and `gabe.xlsx` was an accident, but is interesting because it shows what happens when there are replicated range names.

```{r}
xlsx_read_workbook_defined_names(mini_gap_path)
xlsx_read_workbook_defined_names(dn_path)
xlsx_read_workbook_defined_names(gabe_path)
```

`defined_names` is a tibble with one row per named range and these variables:

  * `name`: name of the named range
  * `refers_to`: string representation of the cell area reference, e.g., `Sheet1!$B$2:$B$11`
  * `sheet_id`: integer *(I can't get my hands on a sheet that has actually this)*
  * `local_sheet_id`: integer *(appears when names are replicated)*

### Workbook rels from xl/_rels/workbook.xml.rels

*We should probably cook up a more interesting example here?*

Mini Gapminder is interesting because you see the sheets aren't numbered exactly as you'd expect (which is [`hadley/readxl#104`](https://github.com/hadley/readxl/issues/104)). Ekaterinburg is also interesting because `target` has a leading slash and includes the `xl` subdirectory. But the re-saved version looks more conventional.

```{r}
(workbook_rels <- xlsx_read_workbook_rels(mini_gap_path))
xlsx_read_workbook_rels(ek_path)
xlsx_read_workbook_rels(ek2_path)
```

`workbook_rels` is a tibble, each row a file, with variables

  * `target`: a file path relative to `xl/` *(maybe prepend xl/?)*
  * `id`: character, e.g., `"rId5"` *(a key that occurs elsewhere)*
  * `type`: a long namespace-y string, the last bit of which tells you
if the associated file is `sharedStrings`, styles, or a worksheet, e.g.,
`http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet`
*(maybe just take the last bit?)*

### Derived object: `sheets_df`

We depart from the philosophy a bit here to create `sheets_df`, a new tibble with one row per worksheet. It joins `sheets`, which came from `workbook.xml`, to `workbook_rels`, which came from `workbook.xml.rels`. This is where we finally get sheet id, sheet name, id, and xml target file all in one place.

```{r}
(sheets_df <- join_sheets_workbook_rels(sheets, workbook_rels))
```


```{r}
mini_gap_path <- system.file("sheets", "mini-gap.xlsx", package = "rexcel")
mini_gap_workbook <- rexcel_register(mini_gap_path)
str(mini_gap_workbook, max.level = 1)
mini_gap_workbook
```

What's here?

  * `xlsx_path`: path to the xlsx
  * `reg_time`: time xlsx was processed
  * `manifest`: file list for the xlsx zip archive
  * `content_types`: tbl representing `[Content_Types].xml`
  * `sheets`: tbl representing `xl/workbook.xml`
  * `sheets_df`:
    - This is really the only thing I created.
    - A tbl with one row per worksheet, from joining `sheets` and `workbook_rels`
  * `shared_strings`: character vector representing `xl/sharedStrings.xml`
  * `styles`: list of tbls from `xl/styles.xml` (ok, I admit, I stopped after parsing fonts)
  * `workbook_rels`:
    - tbl that links target files to `Id`s, also gives file type
    - example: tells you that `Id = rId4` refers to `Target` file `xl/worksheets/sheetX.xml`
    - comes from `xl/_rels/workbook.xml.rels`
  * `worksheet_rels`:
    - *I'm still figuring this one out but it's about files or external resources (potentially) referred to from worksheets*
    - comes from files like` xl/worksheets/_rels/(sheet[0-9]+).xml.rels`
  

```{r}
## enter rexcel_read_workbook()
path <- ff_path
sheets <- 1L

## this gets info about the files inside the zip archive
dat <- xlsx_read_workbook(path)
dat$rels   ## ?files in the zip archive?
dat$sheets ## ?files corresponding to worksheets?
(sheets <- xlsx_sheet_names(dat)[sheets])

(strings <- xlsx_read_shared_strings(path))
(date_offset <- xlsx_date_offset(path))

style_xlsx <- xlsx_read_style(path)
str(style_xlsx, max.level = 1)
(lookup <- tibble::data_frame(
  font    = style_xlsx$cell_xfs$font_id,
  fill    = style_xlsx$cell_xfs$fill_id,
  border  = style_xlsx$cell_xfs$border_id,
  num_fmt = style_xlsx$cell_xfs$num_fmt_id))

## numeric formatting
n <- max(style_xlsx$num_fmts$num_format_id)
fmt <- rep(NA_character_, n)
fmt[seq_along(xlsx_format_codes())] <- xlsx_format_codes()
fmt[style_xlsx$num_fmts$num_format_id] <- style_xlsx$num_fmts$format_code
num_fmt <- tibble::data_frame(num_fmt = fmt)
style <- linen::linen_style(lookup, font = style_xlsx$fonts,
                            fill = style_xlsx$fills,
                            border = style_xlsx$borders,
                            num_fmt = num_fmt)

(workbook <- linen::workbook(sheets, style, dat$defined_names))
```

Objective 2: Visit and extract information for all requested worksheets.

In this case, I'm just reading the first and only sheet. This loop appears in `rexcel_read_workbook()` and calls `rexcel_read_worksheet()` for each requested worksheet. This is the loop and function we eventually exit from and this `workbook` object is what's returned.

```{r}
## enter rexcel_read_worksheet()
## rexcel_read_worksheet(path, s, workbook, dat, strings, style, date_offset)
(sheet <- sheets[1])
(sheet_idx <- match(sheet, workbook$names))
(sheet_name <- sheet)

(target <- xlsx_internal_sheet_name(sheet, dat))
(rels <- xlsx_read_rels(path, target))
```

Now we drop down into a lower-level non-exported function, `xlsx_read_sheet()`.

```{r}
## enter xlsx_read_sheet()
(file <- xlsx_internal_sheet_name(sheet_idx, dat))
xml <- xlsx_read_file(path, file) ## at last! the xml! w00t!
(ns <- xml2::xml_ns(xml)) ## much less w00t now :(

(merged <- xlsx_read_merged(xml, ns))
(view <- xlsx_ct_worksheet_views(xml, ns))
(cols <- xlsx_ct_cols(xml, ns)) # NOTE: not used yet

## this is where it's at!
(cell_dat <- xlsx_parse_cells(xml, ns, strings, style, date_offset))

## not even sure what this is
(rows <- cell_dat$rows)

## this is where cells come from  
(cells <- linen::cells(cell_dat$cells$ref, cell_dat$cells$style,
                       cell_dat$cells$type, cell_dat$cells$value,
                       cell_dat$cells$formula))

## in real life and in other sheets, it's possible comments will be populated
## but not in this sheet
comments <- NULL
```

Now we gather everything we've learned about this worksheet into a `linen::worksheet` object.

```{r}
(ws <- linen::worksheet(sheet_name, cols, rows, cells, merged, view, comments,
                        workbook))
```

If we had other sheets to read, that would be done now. Ultimately this `workbook` is returned.
